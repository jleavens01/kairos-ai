<template>
  <div class="production-table-wrapper">
    <!-- ÏÑ†ÌÉùÎêú Ïî¨Ïù¥ ÏûàÏùÑ Îïå ÌëúÏãúÎêòÎäî Ïï°ÏÖò Î∞î -->
    <div v-if="selectedScenes.length > 0" class="selection-actions">
      <div class="selection-info">
        <span class="selection-count">{{ selectedScenes.length }}Í∞ú Ïî¨ ÏÑ†ÌÉùÎê®</span>
      </div>
      <div class="selection-buttons">
        <button @click="generateBatchTTS" class="btn-tts">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path>
            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
            <line x1="12" y1="19" x2="12" y2="22"></line>
          </svg>
          TTS ÏÉùÏÑ±
        </button>
        <button @click="downloadBatchTTS" class="btn-download-tts">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
          </svg>
          TTS Îã§Ïö¥Î°úÎìú
        </button>
        <button @click="deleteSelectedScenes" class="btn-delete">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="3 6 5 6 21 6"></polyline>
            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            <line x1="10" y1="11" x2="10" y2="17"></line>
            <line x1="14" y1="11" x2="14" y2="17"></line>
          </svg>
          ÏÇ≠Ï†ú
        </button>
      </div>
    </div>
    
    <div class="production-table-container">
      <table class="production-table">
        <thead>
          <tr>
            <th class="scene-number-col">
            <input 
              type="checkbox" 
              :checked="isAllSelected"
              @change="toggleSelectAll"
            >
          </th>
          <th class="scene-image-col">
            <div class="media-header">
              <div class="media-switch-container">
                <span class="media-label" :class="{ active: globalMediaType === 'image' }">Ïù¥ÎØ∏ÏßÄ</span>
                <label class="media-switch">
                  <input 
                    type="checkbox" 
                    :checked="globalMediaType === 'video'"
                    @change="switchGlobalMediaType(globalMediaType === 'image' ? 'video' : 'image')"
                  >
                  <span class="switch-slider"></span>
                </label>
                <span class="media-label" :class="{ active: globalMediaType === 'video' }">ÎπÑÎîîÏò§</span>
              </div>
            </div>
          </th>
          <th class="script-col">Ïä§ÌÅ¨Î¶ΩÌä∏ ÏõêÎ≥∏</th>
          <th class="characters-col">Ïù∏Î¨º</th>
          <th class="tts-col">
            TTS
            <span v-if="totalTTSDuration > 0" class="tts-total-duration">
              ({{ formatDuration(totalTTSDuration) }})
            </span>
          </th>
        </tr>
      </thead>
      <tbody>
        <template v-for="(scene, index) in scenes" :key="scene.id">
          <tr 
            class="production-sheet-data-row"
            :class="{ selected: isSelected(scene.id) }"
            @mouseover="setHoveredItem(scene.id)"
            @mouseleave="clearHoveredItem()"
          >
            <td class="scene-number-col">
              <div class="scene-number-wrapper">
                <input 
                  type="checkbox" 
                  :checked="isSelected(scene.id)"
                  @change="toggleSelect(scene.id)"
                >
                <span class="scene-number">{{ scene.scene_number }}</span>
              </div>
            </td>
            <td class="scene-image-col">
              <SceneImageUploader
                :scene-id="scene.id"
                :scene-number="scene.scene_number"
                :image-url="scene.scene_image_url"
                :video-url="scene.scene_video_url"
                :media-type="globalMediaType"
                :project-id="projectId"
                @update="handleImageUpdate(scene.id, $event)"
                @view-image="showFullImage"
              />
            </td>
            <td class="script-col editable-cell" @click="startEditing(scene.id, 'original_script_text', scene.original_script_text)">
              <template v-if="isEditing(scene.id, 'original_script_text')">
                <textarea 
                  :id="`edit-${scene.id}-original_script_text`"
                  v-model="editedValue"
                  @blur="saveEdit(scene, 'original_script_text')"
                  @keydown.esc.prevent="cancelEdit"
                  @keydown.enter.ctrl="saveEdit(scene, 'original_script_text')"
                  rows="3"
                  class="edit-input edit-textarea"
                ></textarea>
              </template>
              <template v-else>
                {{ scene.original_script_text }}
              </template>
            </td>
            <td class="characters-col editable-cell" @click="startEditingCharacters(scene.id, scene.characters)">
              <template v-if="isEditing(scene.id, 'characters')">
                <input 
                  :id="`edit-${scene.id}-characters`"
                  v-model="editedValue"
                  @blur="handleCharactersBlur(scene)"
                  @keydown.esc.prevent="cancelEdit"
                  @keydown.enter.prevent="handleCharactersEnter(scene)"
                  placeholder="Ï∫êÎ¶≠ÌÑ∞1, Ï∫êÎ¶≠ÌÑ∞2, ..."
                  class="edit-input"
                />
                <div class="edit-hint">ÏâºÌëúÎ°ú Íµ¨Î∂ÑÌïòÏó¨ ÏûÖÎ†• (Enter: Ï†ÄÏû•, Esc: Ï∑®ÏÜå)</div>
              </template>
              <template v-else>
                <div class="tag-list">
                  <span 
                    v-for="(character, idx) in scene.characters" 
                    :key="idx"
                    class="tag character-tag"
                  >
                    {{ character }}
                  </span>
                  <span v-if="!scene.characters || scene.characters.length === 0" class="empty-hint">
                    Ï∫êÎ¶≠ÌÑ∞ Ï∂îÍ∞Ä
                  </span>
                </div>
              </template>
            </td>
            <td class="tts-col">
              <div class="tts-controls">
                <!-- TTSÍ∞Ä ÏóÜÏùÑ Îïå -->
                <button 
                  v-if="!ttsData[scene.id]"
                  @click="generateTTS(scene)"
                  class="tts-generate-btn"
                  :disabled="!scene.original_script_text || loadingTTS[scene.id]"
                >
                  <span v-if="loadingTTS[scene.id]" class="loading-spinner-small"></span>
                  <span v-else>ÏÉùÏÑ±</span>
                </button>
                
                <!-- TTSÍ∞Ä ÏûàÏùÑ Îïå -->
                <template v-else>
                  <button 
                    @click="playTTS(scene.id)"
                    class="tts-play-btn"
                    :class="{ 'playing': playingTTS[scene.id] }"
                  >
                    <span v-if="playingTTS[scene.id]">‚è∏</span>
                    <span v-else>‚ñ∂</span>
                  </button>
                  
                  <span class="tts-duration" v-if="ttsData[scene.id]?.duration">
                    {{ formatDuration(ttsData[scene.id].duration) }}
                  </span>
                  
                  <button 
                    @click="generateTTS(scene, true)"
                    class="tts-regenerate-btn"
                    :disabled="loadingTTS[scene.id]"
                    title="Ïû¨ÏÉùÏÑ±"
                  >
                    <span v-if="loadingTTS[scene.id]" class="loading-spinner-small"></span>
                    <span v-else>Ïû¨ÏÉùÏÑ±</span>
                  </button>
                  
                  <button 
                    @click="downloadTTS(scene)"
                    class="tts-download-btn"
                    title="Îã§Ïö¥Î°úÎìú"
                  >
                    üì•
                  </button>
                </template>
              </div>
            </td>
          </tr>
          <!-- Ïî¨ Ï∂îÍ∞Ä Î≤ÑÌäº Ïò§Î≤ÑÎ†àÏù¥ -->
          <tr v-if="index < scenes.length - 1" class="scene-divider-row">
            <td colspan="6" class="scene-divider-cell">
              <div 
                class="add-scene-overlay"
                :class="{ 'visible': hoveredItemId === scene.id || hoveredItemId === `divider-${scene.id}` }"
                @mouseenter="setHoveredItem(`divider-${scene.id}`)"
                @mouseleave="clearHoveredItem()"
              >
                <button @click="addRow(scene.scene_number)" class="add-scene-overlay-button">
                  + Ïî¨ Ï∂îÍ∞Ä
                </button>
              </div>
            </td>
          </tr>
        </template>
      </tbody>
    </table>
    
    <!-- Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå -->
    <div v-if="scenes.length === 0" class="no-data">
      <p>ÏïÑÏßÅ ÏÉùÏÑ±Îêú Ïî¨Ïù¥ ÏóÜÏäµÎãàÎã§.</p>
    </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, nextTick, onMounted, onUnmounted } from 'vue'
import { useProductionStore } from '@/stores/production'
import { useProjectsStore } from '@/stores/projects'
import { supabase } from '@/utils/supabase'
import SceneImageUploader from './SceneImageUploader.vue'
import JSZip from 'jszip'

const props = defineProps({
  scenes: {
    type: Array,
    default: () => []
  },
  selectedScenes: {
    type: Array,
    default: () => []
  },
  projectId: {
    type: String,
    required: true
  }
})

const emit = defineEmits(['update:selected', 'edit-scene', 'add-scene', 'delete-scene', 'update-scene'])

const productionStore = useProductionStore()
const projectsStore = useProjectsStore()

// State
const editingCell = ref(null)
const editedValue = ref('')
const hoveredItemId = ref(null)
const isSaving = ref(false)
const globalMediaType = ref('image') // Ï†ÑÏ≤¥ ÎØ∏ÎîîÏñ¥ ÌÉÄÏûÖ (image/video)


// TTS Í¥ÄÎ†® ÏÉÅÌÉú
const loadingTTS = ref({})
const ttsData = ref({}) // { sceneId: { file_url, duration, version } }
const playingTTS = ref({})
const audioElements = ref({})

// Computed
const isAllSelected = computed(() => {
  return props.scenes.length > 0 && 
         props.selectedScenes.length === props.scenes.length
})

// TTS Ï¥ù ÎìÄÎ†àÏù¥ÏÖò Í≥ÑÏÇ∞
const totalTTSDuration = computed(() => {
  let total = 0
  props.scenes.forEach(scene => {
    if (ttsData.value[scene.id]?.duration) {
      total += ttsData.value[scene.id].duration
    }
  })
  return total
})

// Methods
const isSelected = (sceneId) => {
  return props.selectedScenes.includes(sceneId)
}

const toggleSelect = (sceneId) => {
  let newSelected = [...props.selectedScenes]
  
  if (isSelected(sceneId)) {
    newSelected = newSelected.filter(id => id !== sceneId)
  } else {
    newSelected.push(sceneId)
  }
  
  emit('update:selected', newSelected)
}

const toggleSelectAll = () => {
  if (isAllSelected.value) {
    emit('update:selected', [])
  } else {
    emit('update:selected', props.scenes.map(s => s.id))
  }
}

// Ïù∏ÎùºÏù∏ Ìé∏Ïßë Í¥ÄÎ†® Ìï®ÏàòÎì§
const startEditing = (sceneId, field, value) => {
  editingCell.value = `${sceneId}-${field}`
  editedValue.value = value || ''
  nextTick(() => {
    const input = document.querySelector(`#edit-${sceneId}-${field}`)
    if (input) {
      input.focus()
      if (input.type === 'textarea') {
        input.setSelectionRange(input.value.length, input.value.length)
      }
    }
  })
}

const startEditingCharacters = (sceneId, characters) => {
  editingCell.value = `${sceneId}-characters`
  // Î∞∞Ïó¥ÏùÑ ÏâºÌëúÎ°ú Íµ¨Î∂ÑÎêú Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
  editedValue.value = characters ? characters.join(', ') : ''
  nextTick(() => {
    const input = document.querySelector(`#edit-${sceneId}-characters`)
    if (input) {
      input.focus()
      input.setSelectionRange(input.value.length, input.value.length)
    }
  })
}

const saveEdit = async (scene, field) => {
  if (editedValue.value === scene[field]) {
    cancelEdit()
    return
  }
  
  console.log(`Saving ${field}:`, editedValue.value)
  console.log('Scene ID:', scene.id)
  
  try {
    // Supabase ÏßÅÏ†ë Ìò∏Ï∂ú
    const { data, error } = await supabase
      .from('production_sheets')
      .update({ [field]: editedValue.value })
      .eq('id', scene.id)
      .select()
      .single()
    
    console.log(`Direct Supabase response for ${field}:`, { data, error })
    
    if (error) {
      console.error('Supabase error:', error)
      alert(`Ï†ÄÏû•Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ${error.message}`)
    } else {
      console.log(`${field} saved successfully, data:`, data)
      console.log('Full scene data after save:', data)
      
      // Î°úÏª¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ - Ìï¥Îãπ ÌïÑÎìúÎßå ÏóÖÎç∞Ïù¥Ìä∏
      if (data[field] !== undefined) {
        scene[field] = data[field]
      }
      
      // Store ÏÉÅÌÉúÎèÑ ÏóÖÎç∞Ïù¥Ìä∏ - Ìï¥Îãπ ÌïÑÎìúÎßå ÏóÖÎç∞Ïù¥Ìä∏
      const index = productionStore.productionSheets.findIndex(sheet => sheet.id === scene.id)
      if (index !== -1 && data[field] !== undefined) {
        productionStore.productionSheets[index][field] = data[field]
      }
    }
  } catch (err) {
    console.error('Unexpected error:', err)
    alert('ÏòàÏÉÅÏπò Î™ªÌïú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.')
  }
  
  cancelEdit()
}

// Enter ÌÇ§ Ìï∏Îì§Îü¨
const handleCharactersEnter = async (scene) => {
  await saveCharactersEdit(scene)
}

// Blur Ìï∏Îì§Îü¨
const handleCharactersBlur = async (scene) => {
  // Enter ÌÇ§Î°ú Ïù∏Ìïú blur Ïù¥Î≤§Ìä∏Îäî Î¨¥Ïãú
  if (editingCell.value === null) {
    return
  }
  await saveCharactersEdit(scene)
}

const saveCharactersEdit = async (scene) => {
  // Ïù¥ÎØ∏ Ï†ÄÏû• Ï§ëÏù¥Î©¥ Î¨¥Ïãú
  if (isSaving.value) {
    console.log('Already saving, ignoring duplicate call')
    return
  }
  
  // ÏâºÌëúÎ°ú Íµ¨Î∂ÑÎêú Î¨∏ÏûêÏó¥ÏùÑ Î∞∞Ïó¥Î°ú Î≥ÄÌôò
  const newCharacters = editedValue.value
    .split(',')
    .map(char => char.trim())
    .filter(char => char.length > 0)
  
  // Î≥ÄÍ≤ΩÏÇ¨Ìï≠Ïù¥ ÏóÜÏúºÎ©¥ Ï∑®ÏÜå
  const oldCharacters = scene.characters || []
  if (JSON.stringify(newCharacters) === JSON.stringify(oldCharacters)) {
    cancelEdit()
    return
  }
  
  isSaving.value = true
  console.log('Saving characters as array:', newCharacters)
  console.log('Scene ID:', scene.id)
  
  try {
    // PostgreSQL TEXT[] Î∞∞Ïó¥Î°ú Ï†ÄÏû•
    const { data, error } = await supabase
      .from('production_sheets')
      .update({ 
        characters: newCharacters  // JavaScript Î∞∞Ïó¥Ïù¥ ÏûêÎèôÏúºÎ°ú PostgreSQL Î∞∞Ïó¥Î°ú Î≥ÄÌôòÎê®
      })
      .eq('id', scene.id)
      .select()
      .single()
    
    console.log('Supabase response:', { data, error })
    
    if (error) {
      console.error('Supabase error:', error)
      alert('Ï∫êÎ¶≠ÌÑ∞ Ï†ÄÏû•Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ' + error.message)
    } else {
      console.log('Characters saved successfully:', data.characters)
      console.log('Full scene data after save:', data)
      
      // Î°úÏª¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ - charactersÎßå ÏóÖÎç∞Ïù¥Ìä∏
      if (data.characters !== undefined) {
        scene.characters = data.characters
      }
      
      // Store ÏÉÅÌÉúÎèÑ ÏóÖÎç∞Ïù¥Ìä∏ - charactersÎßå ÏóÖÎç∞Ïù¥Ìä∏
      const index = productionStore.productionSheets.findIndex(sheet => sheet.id === scene.id)
      if (index !== -1 && data.characters !== undefined) {
        productionStore.productionSheets[index].characters = data.characters
      }
    }
  } catch (err) {
    console.error('Unexpected error:', err)
    alert('ÏòàÏÉÅÏπò Î™ªÌïú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.')
  } finally {
    cancelEdit()  // editingCellÏùÑ nullÎ°ú ÎßåÎì§Ïñ¥ÏÑú blur Ïù¥Î≤§Ìä∏Í∞Ä Î¨¥ÏãúÎêòÎèÑÎ°ù Ìï®
    setTimeout(() => {
      isSaving.value = false  // ÏïΩÍ∞ÑÏùò ÏßÄÏó∞ ÌõÑ ÌîåÎûòÍ∑∏ Ìï¥Ï†ú
    }, 100)
  }
}

const cancelEdit = () => {
  editingCell.value = null
  editedValue.value = ''
}

const isEditing = (sceneId, field) => {
  return editingCell.value === `${sceneId}-${field}`
}

// Ìò∏Î≤Ñ Í¥ÄÎ†® Ìï®ÏàòÎì§
const setHoveredItem = (itemId) => {
  hoveredItemId.value = itemId
}

const clearHoveredItem = () => {
  hoveredItemId.value = null
}

// Ïî¨ Ï∂îÍ∞Ä Ìï®Ïàò (Netlify Function ÏÇ¨Ïö©)
const addRow = async (afterSceneNumber) => {
  try {
    // ÌÜ†ÌÅ∞ Í∞ÄÏ†∏Ïò§Í∏∞
    const { data: { session } } = await supabase.auth.getSession()
    if (!session) {
      alert('Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.')
      return
    }
    
    console.log('Adding scene after scene number:', afterSceneNumber)
    
    // Netlify Function Ìò∏Ï∂ú
    const response = await fetch('/.netlify/functions/addProductionSheetRow', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${session.access_token}`
      },
      body: JSON.stringify({
        projectId: props.projectId,
        afterSceneNumber: afterSceneNumber
      })
    })
    
    if (!response.ok) {
      const error = await response.json()
      console.error('Ïî¨ Ï∂îÍ∞Ä Ïã§Ìå®:', error)
      
      // Ï§ëÎ≥µ ÌÇ§ Ïò§Î•òÏù∏ Í≤ΩÏö∞ Ïû¨ÏãúÎèÑ
      if (error.error && error.error.includes('duplicate key')) {
        console.log('Duplicate key error detected, refreshing and retrying...')
        
        // Î®ºÏ†Ä ÏµúÏã† Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
        await productionStore.fetchProductionSheets(props.projectId)
        
        // ÎßàÏßÄÎßâ Ïî¨ Î≤àÌò∏ Ï∞æÍ∏∞
        const maxSceneNumber = Math.max(...props.scenes.map(s => s.scene_number || 0))
        
        // ÎßàÏßÄÎßâÏóê Ï∂îÍ∞Ä
        const retryResponse = await fetch('/.netlify/functions/addProductionSheetRow', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${session.access_token}`
          },
          body: JSON.stringify({
            projectId: props.projectId,
            afterSceneNumber: maxSceneNumber
          })
        })
        
        if (!retryResponse.ok) {
          const retryError = await retryResponse.json()
          console.error('Ïû¨ÏãúÎèÑ Ïã§Ìå®:', retryError)
          alert('Ïî¨ Ï∂îÍ∞ÄÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. ÌéòÏù¥ÏßÄÎ•º ÏÉàÎ°úÍ≥†Ïπ® ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.')
          return
        }
      } else {
        alert(`Ïî¨ Ï∂îÍ∞ÄÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ${error.error || 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò'}`)
        return
      }
    }
    
    // ÌîÑÎ°úÎçïÏÖò ÏãúÌä∏ Îã§Ïãú Î°úÎìú
    await productionStore.fetchProductionSheets(props.projectId)
  } catch (err) {
    console.error('Ïî¨ Ï∂îÍ∞Ä Ï§ë Ïò§Î•ò:', err)
    alert('Ïî¨ Ï∂îÍ∞Ä Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.')
  }
}

// ÏÑ†ÌÉù Ìï¥Ï†ú
const clearSelection = () => {
  emit('update:selected', [])
}

// Ïî¨ ÏÇ≠Ï†ú Ìï®Ïàò (Netlify Function ÏÇ¨Ïö©)
const deleteSelectedScenes = async () => {
  if (props.selectedScenes.length === 0) {
    alert('ÏÇ≠Ï†úÌï† Ïî¨ÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.')
    return
  }
  
  if (!confirm(`ÏÑ†ÌÉùÌïú ${props.selectedScenes.length}Í∞úÏùò Ïî¨ÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?`)) {
    return
  }
  
  try {
    // ÌÜ†ÌÅ∞ Í∞ÄÏ†∏Ïò§Í∏∞
    const { data: { session } } = await supabase.auth.getSession()
    if (!session) {
      alert('Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.')
      return
    }
    
    // Netlify Function Ìò∏Ï∂ú
    const response = await fetch('/.netlify/functions/deleteProductionSheetRows', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${session.access_token}`
      },
      body: JSON.stringify({
        projectId: props.projectId,
        idsToDelete: props.selectedScenes
      })
    })
    
    if (!response.ok) {
      const error = await response.json()
      console.error('Ïî¨ ÏÇ≠Ï†ú Ïã§Ìå®:', error)
      alert(`Ïî¨ ÏÇ≠Ï†úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ${error.error || 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò'}`)
      return
    }
    
    // ÏÑ†ÌÉù Ìï¥Ï†ú Î∞è ÌîÑÎ°úÎçïÏÖò ÏãúÌä∏ Îã§Ïãú Î°úÎìú
    emit('update:selected', [])
    await productionStore.fetchProductionSheets(props.projectId)
  } catch (err) {
    console.error('Ïî¨ ÏÇ≠Ï†ú Ï§ë Ïò§Î•ò:', err)
    alert('Ïî¨ ÏÇ≠Ï†ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.')
  }
}

// Duration Ìè¨Îß∑ Ìï®Ïàò
const formatDuration = (seconds) => {
  if (!seconds) return '0:00'
  const totalSeconds = Math.round(seconds) // Î∞òÏò¨Î¶º
  const mins = Math.floor(totalSeconds / 60)
  const secs = totalSeconds % 60
  return `${mins}:${secs.toString().padStart(2, '0')}`
}

// ÌÖçÏä§Ìä∏ ÌååÏã± Ìï®Ïàò
const parseTextForTTS = (text) => {
  let processedText = text
  
  // 1. Í¥ÑÌò∏ Ïïà ÎÇ¥Ïö© Ï†úÍ±∞ (ÏßÄÏãúÎ¨∏, Ïó∞Ï∂ú ÎÖ∏Ìä∏ Îì±)
  processedText = processedText.replace(/\([^)]*\)/g, '')
  processedText = processedText.replace(/\[[^\]]*\]/g, '')
  processedText = processedText.replace(/\{[^}]*\}/g, '')
  
  // 2. Ïù¥Î™®ÏßÄ Î∞è ÌäπÏàò Ïú†ÎãàÏΩîÎìú Î¨∏Ïûê Ï†úÍ±∞
  processedText = processedText.replace(/[\u{1F600}-\u{1F64F}]/gu, '') // Ïù¥Î™®Ìã∞ÏΩò
  processedText = processedText.replace(/[\u{1F300}-\u{1F5FF}]/gu, '') // Í∏∞ÌÉÄ Í∏∞Ìò∏
  processedText = processedText.replace(/[\u{1F680}-\u{1F6FF}]/gu, '') // ÍµêÌÜµ/ÏßÄÎèÑ Í∏∞Ìò∏
  processedText = processedText.replace(/[\u{2600}-\u{26FF}]/gu, '')   // Í∏∞ÌÉÄ Í∏∞Ìò∏
  processedText = processedText.replace(/[\u{2700}-\u{27BF}]/gu, '')   // Îî©Î±É
  
  // 3. Îî∞Ïò¥Ìëú Ï†úÍ±∞ (ÎåÄÌôîÎ¨∏ ÌëúÏãúÏö© Îî∞Ïò¥Ìëú Î™®Îëê Ï†úÍ±∞)
  processedText = processedText.replace(/[""""]/g, '') // ÌÅ∞Îî∞Ïò¥Ìëú Ï†úÍ±∞
  processedText = processedText.replace(/['''']/g, '') // ÏûëÏùÄÎî∞Ïò¥Ìëú Ï†úÍ±∞
  processedText = processedText.replace(/[„Äå„Äç„Äé„Äè]/g, '') // ÏùºÎ≥∏Ïñ¥ Îî∞Ïò¥Ìëú Ï†úÍ±∞
  processedText = processedText.replace(/[„Ää„Äã„Äà„Äâ]/g, '') // Ï§ëÍµ≠Ïñ¥ Îî∞Ïò¥Ìëú Ï†úÍ±∞
  processedText = processedText.replace(/[ÔΩ¢ÔΩ£]/g, '') // Î∞òÍ∞Å Îî∞Ïò¥Ìëú Ï†úÍ±∞
  processedText = processedText.replace(/[`¬¥]/g, '') // Î∞±Ìã±Í≥º ÏñµÏùå Î∂ÄÌò∏ Ï†úÍ±∞
  
  // 4. ÌäπÏàò Î¨∏Ïûê Ï≤òÎ¶¨
  processedText = processedText.replace(/[‚ô™‚ô´‚ô¨‚ô≠‚ôÆ‚ôØ]/g, '') // ÏùåÏïÖ Í∏∞Ìò∏
  processedText = processedText.replace(/[‚òÖ‚òÜ‚ô•‚ô°]/g, '') // Î≥Ñ, ÌïòÌä∏ Îì±
  processedText = processedText.replace(/[‚Äª‚ñ∂‚óÄ‚ñ†‚ñ°‚ñ≤‚ñ≥‚ñº‚ñΩ‚óã‚óè‚óé‚óá‚óÜ]/g, '') // ÎèÑÌòï
  
  // 5. Ïó∞ÏÜçÎêú ÌäπÏàò Î¨∏Ïûê Ï†ïÎ¶¨
  processedText = processedText.replace(/[!?]{2,}/g, match => match[0]) // Ïó∞ÏÜçÎêú ÎäêÎÇåÌëú/Î¨ºÏùåÌëúÎ•º ÌïòÎÇòÎ°ú
  processedText = processedText.replace(/\.{3,}/g, '...') // Ïó∞ÏÜçÎêú ÎßàÏπ®ÌëúÎ•º ...Î°ú
  processedText = processedText.replace(/[~]{2,}/g, '~') // Ïó∞ÏÜçÎêú Î¨ºÍ≤∞ÌëúÎ•º ÌïòÎÇòÎ°ú
  
  // 6. Ï§ÑÎ∞îÍøà Î∞è Í≥µÎ∞± Ï†ïÎ¶¨
  processedText = processedText.replace(/\n{3,}/g, '\n\n') // 3Í∞ú Ïù¥ÏÉÅÏùò Ï§ÑÎ∞îÍøàÏùÑ 2Í∞úÎ°ú
  processedText = processedText.replace(/\s+/g, ' ') // Ïó∞ÏÜçÎêú Í≥µÎ∞±ÏùÑ ÌïòÎÇòÎ°ú
  processedText = processedText.trim() // ÏïûÎí§ Í≥µÎ∞± Ï†úÍ±∞
  
  return processedText
}

// TTS ÏÉùÏÑ± Ìï®Ïàò
const generateTTS = async (scene, regenerate = false) => {
  if (!scene.original_script_text) {
    alert('Ïä§ÌÅ¨Î¶ΩÌä∏ ÌÖçÏä§Ìä∏Í∞Ä ÏóÜÏäµÎãàÎã§.')
    return
  }
  
  // ÌÖçÏä§Ìä∏ ÌååÏã± (ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÏÑú ÎØ∏Î¶¨ ÌôïÏù∏)
  const parsedText = parseTextForTTS(scene.original_script_text)
  if (!parsedText || parsedText.length === 0) {
    alert('ÌÖçÏä§Ìä∏ Ï≤òÎ¶¨ ÌõÑ ÎÇ¥Ïö©Ïù¥ ÏóÜÏäµÎãàÎã§. Ïä§ÌÅ¨Î¶ΩÌä∏Î•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.')
    return
  }
  
  try {
    // ÌÜ†ÌÅ∞ Í∞ÄÏ†∏Ïò§Í∏∞
    const { data: { session } } = await supabase.auth.getSession()
    if (!session) {
      alert('Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.')
      return
    }
    
    loadingTTS.value[scene.id] = true
    
    // TTS ÏÉùÏÑ± API Ìò∏Ï∂ú (ÏõêÎ≥∏ ÌÖçÏä§Ìä∏Î•º Î≥¥ÎÇ¥Í≥† ÏÑúÎ≤ÑÏóêÏÑú ÌååÏã±)
    const response = await fetch('/.netlify/functions/generateTTS', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${session.access_token}`
      },
      body: JSON.stringify({
        projectId: props.projectId,
        sceneId: scene.id,
        text: scene.original_script_text // ÏõêÎ≥∏ ÌÖçÏä§Ìä∏Î•º Î≥¥ÎÉÑ (ÏÑúÎ≤ÑÏóêÏÑú ÌååÏã±)
      })
    })
    
    if (!response.ok) {
      const error = await response.json()
      throw new Error(error.error || 'TTS ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.')
    }
    
    const result = await response.json()
    console.log('TTS generated:', result)
    
    // Ïò§ÎîîÏò§ ÏöîÏÜå ÏÉùÏÑ± Î∞è duration Í≥ÑÏÇ∞
    if (!audioElements.value[scene.id]) {
      audioElements.value[scene.id] = new Audio()
    }
    const audio = audioElements.value[scene.id]
    audio.src = result.data.file_url
    
    // Ïò§ÎîîÏò§ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î°úÎìú ÎåÄÍ∏∞ÌïòÏó¨ duration ÏñªÍ∏∞
    await new Promise((resolve) => {
      audio.addEventListener('loadedmetadata', () => {
        // TTS Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
        ttsData.value[scene.id] = {
          file_url: result.data.file_url,
          duration: audio.duration,
          version: result.data.version
        }
        
        // DurationÏùÑ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ï†ÄÏû•
        saveTTSDuration(scene.id, audio.duration, result.data.version)
        resolve()
      }, { once: true })
      
      audio.load()
    })
    
    if (regenerate) {
      alert('TTSÍ∞Ä Ïû¨ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.')
    } else {
      alert('TTSÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.')
    }
  } catch (error) {
    console.error('TTS ÏÉùÏÑ± Ïò§Î•ò:', error)
    alert(`TTS ÏÉùÏÑ± Ïã§Ìå®: ${error.message}`)
  } finally {
    loadingTTS.value[scene.id] = false
  }
}

// TTS duration Ï†ÄÏû• Ìï®Ïàò
const saveTTSDuration = async (sceneId, duration, version) => {
  try {
    const { error } = await supabase
      .from('tts_audio')
      .update({ duration })
      .eq('scene_id', sceneId)
      .eq('version', version || 1)
    
    if (error) {
      console.error('Duration Ï†ÄÏû• Ïã§Ìå®:', error)
    }
  } catch (err) {
    console.error('Duration Ï†ÄÏû• Ïò§Î•ò:', err)
  }
}

// ÏùºÍ¥Ñ TTS ÏÉùÏÑ± Ìï®Ïàò
const generateBatchTTS = async () => {
  if (props.selectedScenes.length === 0) {
    alert('TTSÎ•º ÏÉùÏÑ±Ìï† Ïî¨ÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.')
    return
  }
  
  // ÏÑ†ÌÉùÎêú Ïî¨Îì§ Ï§ë Ïä§ÌÅ¨Î¶ΩÌä∏Í∞Ä ÏûàÎäî Ïî¨Îßå ÌïÑÌÑ∞ÎßÅ
  const scenesWithScript = props.scenes
    .filter(scene => {
      if (!props.selectedScenes.includes(scene.id) || !scene.original_script_text) {
        return false
      }
      // ÌååÏã± ÌõÑ ÌÖçÏä§Ìä∏Í∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
      const parsed = parseTextForTTS(scene.original_script_text)
      return parsed && parsed.length > 0
    })
  
  if (scenesWithScript.length === 0) {
    alert('ÏÑ†ÌÉùÎêú Ïî¨Ïóê Ïú†Ìö®Ìïú Ïä§ÌÅ¨Î¶ΩÌä∏Í∞Ä ÏóÜÏäµÎãàÎã§.')
    return
  }
  
  const confirmMessage = `${scenesWithScript.length}Í∞ú Ïî¨Ïùò TTSÎ•º ÏÉùÏÑ±ÌïòÏãúÍ≤†ÏäµÎãàÍπå?`
  if (!confirm(confirmMessage)) {
    return
  }
  
  try {
    // ÌÜ†ÌÅ∞ Í∞ÄÏ†∏Ïò§Í∏∞
    const { data: { session } } = await supabase.auth.getSession()
    if (!session) {
      alert('Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.')
      return
    }
    
    // Î™®Îì† Ïî¨Ïóê ÎåÄÌï¥ Î°úÎî© ÏÉÅÌÉú ÏÑ§Ï†ï
    scenesWithScript.forEach(scene => {
      loadingTTS.value[scene.id] = true
    })
    
    // ElevenLabs APIÎäî ÎèôÏãúÏóê 5Í∞úÍπåÏßÄÎßå ÌóàÏö©ÌïòÎØÄÎ°ú Î∞∞ÏπòÎ°ú ÎÇòÎàÑÏñ¥ Ï≤òÎ¶¨
    const batchSize = 5
    const batches = []
    
    for (let i = 0; i < scenesWithScript.length; i += batchSize) {
      batches.push(scenesWithScript.slice(i, i + batchSize))
    }
    
    const allResults = []
    
    // Í∞Å Î∞∞ÏπòÎ•º ÏàúÏ∞®Ï†ÅÏúºÎ°ú Ï≤òÎ¶¨
    for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
      const batch = batches[batchIndex]
      console.log(`Î∞∞Ïπò ${batchIndex + 1}/${batches.length} Ï≤òÎ¶¨ Ï§ë (${batch.length}Í∞ú Ïî¨)`)
      
      // ÌòÑÏû¨ Î∞∞ÏπòÏùò TTS ÏÉùÏÑ± ÏöîÏ≤≠Îì§ (Î∞∞Ïπò ÎÇ¥ÏóêÏÑúÎäî Î≥ëÎ†¨ Ï≤òÎ¶¨)
      const batchPromises = batch.map(async (scene) => {
        try {
          const response = await fetch('/.netlify/functions/generateTTS', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${session.access_token}`
            },
            body: JSON.stringify({
              projectId: props.projectId,
              sceneId: scene.id,
              text: scene.original_script_text
            })
          })
          
          if (!response.ok) {
            const error = await response.json()
            throw new Error(error.error || 'TTS ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.')
          }
          
          const result = await response.json()
          
          // Ïò§ÎîîÏò§ ÏöîÏÜå ÏÉùÏÑ± Î∞è duration Í≥ÑÏÇ∞
          if (!audioElements.value[scene.id]) {
            audioElements.value[scene.id] = new Audio()
          }
          const audio = audioElements.value[scene.id]
          audio.src = result.data.file_url
          
          // Ïò§ÎîîÏò§ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î°úÎìú ÎåÄÍ∏∞
          await new Promise((resolve) => {
            audio.addEventListener('loadedmetadata', () => {
              // TTS Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
              ttsData.value[scene.id] = {
                file_url: result.data.file_url,
                duration: audio.duration,
                version: result.data.version
              }
              
              // DurationÏùÑ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ï†ÄÏû•
              saveTTSDuration(scene.id, audio.duration, result.data.version)
              
              resolve()
            }, { once: true })
            
            audio.load()
          })
          
          return { success: true, sceneId: scene.id, sceneNumber: scene.scene_number }
        } catch (error) {
          console.error(`Ïî¨ ${scene.scene_number} TTS ÏÉùÏÑ± Ïã§Ìå®:`, error)
          return { success: false, sceneId: scene.id, sceneNumber: scene.scene_number, error: error.message }
        } finally {
          loadingTTS.value[scene.id] = false
        }
      })
      
      // ÌòÑÏû¨ Î∞∞ÏπòÏùò Î™®Îì† ÏöîÏ≤≠Ïù¥ ÏôÑÎ£åÎê† ÎïåÍπåÏßÄ ÎåÄÍ∏∞
      const batchResults = await Promise.allSettled(batchPromises)
      allResults.push(...batchResults)
      
      console.log(`Î∞∞Ïπò ${batchIndex + 1} ÏôÑÎ£å: ${batchResults.filter(r => r.value?.success).length}Í∞ú ÏÑ±Í≥µ`)
      
      // Îã§Ïùå Î∞∞Ïπò Ï≤òÎ¶¨ Ï†Ñ 1Ï¥à ÎåÄÍ∏∞ (API Ï†úÌïú ÌöåÌîº)
      if (batchIndex < batches.length - 1) {
        console.log('Îã§Ïùå Î∞∞Ïπò Ï≤òÎ¶¨ Ï†Ñ ÎåÄÍ∏∞ Ï§ë...')
        await new Promise(resolve => setTimeout(resolve, 1000))
      }
    }
    
    // Î™®Îì† Í≤∞Í≥ºÎ•º resultsÏóê Ìï†Îãπ
    const results = allResults
    
    // Í≤∞Í≥º ÏßëÍ≥Ñ
    const successCount = results.filter(r => r.status === 'fulfilled' && r.value.success).length
    const failCount = results.filter(r => r.status === 'rejected' || (r.status === 'fulfilled' && !r.value.success)).length
    
    // ÏÑ†ÌÉù Ìï¥Ï†ú
    clearSelection()
    
    // Í≤∞Í≥º ÏïåÎ¶º
    if (failCount === 0) {
      alert(`${successCount}Í∞ú Ïî¨Ïùò TTSÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.`)
    } else {
      alert(`TTS ÏÉùÏÑ± ÏôÑÎ£å: ÏÑ±Í≥µ ${successCount}Í∞ú, Ïã§Ìå® ${failCount}Í∞ú`)
    }
    
  } catch (error) {
    console.error('ÏùºÍ¥Ñ TTS ÏÉùÏÑ± Ïò§Î•ò:', error)
    alert(`ÏùºÍ¥Ñ TTS ÏÉùÏÑ± Ïã§Ìå®: ${error.message}`)
    
    // Î™®Îì† Î°úÎî© ÏÉÅÌÉú Ìï¥Ï†ú
    scenesWithScript.forEach(scene => {
      loadingTTS.value[scene.id] = false
    })
  }
}

// TTS ÏùºÍ¥Ñ Îã§Ïö¥Î°úÎìú Ìï®Ïàò
const downloadBatchTTS = async () => {
  if (props.selectedScenes.length === 0) {
    alert('Îã§Ïö¥Î°úÎìúÌï† TTSÎ•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.')
    return
  }
  
  // ÏÑ†ÌÉùÎêú Ïî¨Îì§ Ï§ë TTSÍ∞Ä ÏûàÎäî Ïî¨Îßå ÌïÑÌÑ∞ÎßÅ
  const scenesWithTTS = props.scenes.filter(scene => {
    return props.selectedScenes.includes(scene.id) && ttsData.value[scene.id]?.file_url
  })
  
  if (scenesWithTTS.length === 0) {
    alert('ÏÑ†ÌÉùÎêú Ïî¨Ïóê Îã§Ïö¥Î°úÎìú Í∞ÄÎä•Ìïú TTSÍ∞Ä ÏóÜÏäµÎãàÎã§.')
    return
  }
  
  try {
    // ÌîÑÎ°úÏ†ùÌä∏ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞ - currentProjectÍ∞Ä ÏóÜÏúºÎ©¥ ÏßÅÏ†ë Í∞ÄÏ†∏Ïò§Í∏∞
    let projectName = projectsStore.currentProject?.name
    
    if (!projectName) {
      // projectIdÎ°ú ÌîÑÎ°úÏ†ùÌä∏ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
      await projectsStore.getProject(props.projectId)
      projectName = projectsStore.currentProject?.name || 'project'
    }
    
    // ZIP ÌååÏùº ÏÉùÏÑ±
    const zip = new JSZip()
    
    // Í∞Å TTS ÌååÏùº Îã§Ïö¥Î°úÎìú Î∞è ZIPÏóê Ï∂îÍ∞Ä
    const downloadPromises = scenesWithTTS.map(async (scene) => {
      try {
        const tts = ttsData.value[scene.id]
        const response = await fetch(tts.file_url)
        
        if (!response.ok) {
          throw new Error(`Failed to download TTS for scene ${scene.scene_number}`)
        }
        
        const blob = await response.blob()
        const fileName = `TTS_${projectName}_${scene.scene_number}.mp3`
        
        // ZIPÏóê ÌååÏùº Ï∂îÍ∞Ä
        zip.file(fileName, blob)
        
        return { success: true, sceneNumber: scene.scene_number }
      } catch (error) {
        console.error(`Scene ${scene.scene_number} TTS download failed:`, error)
        return { success: false, sceneNumber: scene.scene_number, error: error.message }
      }
    })
    
    // Î™®Îì† Îã§Ïö¥Î°úÎìú ÏôÑÎ£å ÎåÄÍ∏∞
    const results = await Promise.allSettled(downloadPromises)
    const successCount = results.filter(r => r.value?.success).length
    const failCount = results.filter(r => !r.value?.success).length
    
    if (successCount === 0) {
      alert('Îã§Ïö¥Î°úÎìú Í∞ÄÎä•Ìïú TTS ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.')
      return
    }
    
    // ZIP ÌååÏùº ÏÉùÏÑ± Î∞è Îã§Ïö¥Î°úÎìú
    const zipBlob = await zip.generateAsync({ type: 'blob' })
    const url = URL.createObjectURL(zipBlob)
    const link = document.createElement('a')
    link.href = url
    link.download = `TTS_${projectName}_batch.zip`
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    URL.revokeObjectURL(url)
    
    // Í≤∞Í≥º ÏïåÎ¶º
    if (failCount > 0) {
      alert(`TTS Îã§Ïö¥Î°úÎìú ÏôÑÎ£å: ÏÑ±Í≥µ ${successCount}Í∞ú, Ïã§Ìå® ${failCount}Í∞ú`)
    } else {
      alert(`${successCount}Í∞ú TTS ÌååÏùºÏù¥ Îã§Ïö¥Î°úÎìúÎêòÏóàÏäµÎãàÎã§.`)
    }
    
    // ÏÑ†ÌÉù Ìï¥Ï†ú
    clearSelection()
    
  } catch (error) {
    console.error('TTS ÏùºÍ¥Ñ Îã§Ïö¥Î°úÎìú Ïò§Î•ò:', error)
    alert(`TTS Îã§Ïö¥Î°úÎìú Ïã§Ìå®: ${error.message}`)
  }
}

// TTS Îã§Ïö¥Î°úÎìú Ìï®Ïàò
const downloadTTS = async (scene) => {
  const tts = ttsData.value[scene.id]
  if (!tts || !tts.file_url) {
    alert('TTS ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.')
    return
  }
  
  try {
    // ÌîÑÎ°úÏ†ùÌä∏ Ïù¥Î¶Ñ Í∞ÄÏ†∏Ïò§Í∏∞
    const projectName = currentProject.value?.name || 'untitled'
    const sceneNumber = scene.scene_number || 'unknown'
    
    // Î≤ÑÏ†Ñ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞ (tts.versionÏù¥ ÏûàÏúºÎ©¥ ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ v1)
    const version = tts.version || 'v1'
    
    // ÌååÏùºÎ™Ö ÏÉùÏÑ± (ÌäπÏàòÎ¨∏Ïûê Ï†úÍ±∞)
    const sanitizedProjectName = projectName.replace(/[^a-zA-Z0-9Í∞Ä-Ìû£]/g, '_')
    const fileName = `TTS_${sanitizedProjectName}_${sceneNumber}_${version}.wav`
    
    // TTS ÌååÏùº Îã§Ïö¥Î°úÎìú
    const response = await fetch(tts.file_url)
    const blob = await response.blob()
    const url = URL.createObjectURL(blob)
    
    const link = document.createElement('a')
    link.href = url
    link.download = fileName
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    
    // Î©îÎ™®Î¶¨ Ï†ïÎ¶¨
    URL.revokeObjectURL(url)
  } catch (error) {
    console.error('TTS Îã§Ïö¥Î°úÎìú Ïò§Î•ò:', error)
    // Ïã§Ìå® Ïãú Í∏∞Î≥∏ Îã§Ïö¥Î°úÎìú
    const link = document.createElement('a')
    link.href = tts.file_url
    link.download = `TTS_${scene.id}_v1.wav`
    link.click()
  }
}

// TTS Ïû¨ÏÉù/ÏùºÏãúÏ†ïÏßÄ Ìï®Ïàò
const playTTS = async (sceneId) => {
  if (!audioElements.value[sceneId]) {
    // ttsDataÏóêÏÑú URL Í∞ÄÏ†∏Ïò§Í∏∞
    const tts = ttsData.value[sceneId]
    if (!tts || !tts.file_url) {
      alert('TTS ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.')
      return
    }
    
    audioElements.value[sceneId] = new Audio(tts.file_url)
  }
  
  const audio = audioElements.value[sceneId]
  
  if (playingTTS.value[sceneId]) {
    // ÏùºÏãúÏ†ïÏßÄ
    audio.pause()
    playingTTS.value[sceneId] = false
  } else {
    // Ïû¨ÏÉù
    try {
      // Îã§Î•∏ Ïû¨ÏÉù Ï§ëÏù∏ Ïò§ÎîîÏò§ Ï†ïÏßÄ
      Object.keys(audioElements.value).forEach(id => {
        if (id !== sceneId && audioElements.value[id]) {
          audioElements.value[id].pause()
          playingTTS.value[id] = false
        }
      })
      
      await audio.play()
      playingTTS.value[sceneId] = true
      
      // Ïû¨ÏÉù ÏôÑÎ£å Ïãú ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      audio.onended = () => {
        playingTTS.value[sceneId] = false
      }
    } catch (error) {
      console.error('Ïò§ÎîîÏò§ Ïû¨ÏÉù Ïò§Î•ò:', error)
      alert('Ïò§ÎîîÏò§ Ïû¨ÏÉùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.')
    }
  }
}

// Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Í¥ÄÎ†® Î©îÏÑúÎìú
const handleImageUpdate = async () => {
  // Ïä§ÌÜ†Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏
  await productionStore.fetchProductionSheets(props.projectId)
}

const showFullImage = (mediaUrl) => {
  // Ï†ÑÏ≤¥ ÌôîÎ©¥ ÎØ∏ÎîîÏñ¥ Î≥¥Í∏∞ (Í∞ÑÎã®Ìïú Î™®Îã¨ ÎòêÎäî ÏÉà Ï∞Ω)
  window.open(mediaUrl, '_blank')
}

// Ï†ÑÏ≤¥ ÎØ∏ÎîîÏñ¥ ÌÉÄÏûÖ Ïä§ÏúÑÏπò Ìï∏Îì§Îü¨
const switchGlobalMediaType = (newType) => {
  globalMediaType.value = newType
  console.log(`Ï†ÑÏ≤¥ ÎØ∏ÎîîÏñ¥ ÌÉÄÏûÖÏù¥ ${newType}Î°ú Î≥ÄÍ≤ΩÎêòÏóàÏäµÎãàÎã§.`)
}

// TTS ÌååÏùº Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏ (Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏ Ïãú)
const checkExistingTTS = async () => {
  if (!props.scenes.length) return
  
  const sceneIds = props.scenes.map(s => s.id)
  
  // Í∞Å Ïî¨Ïùò ÏµúÏã† TTS Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
  const { data } = await supabase
    .from('tts_audio')
    .select('scene_id, file_url, duration, version')
    .in('scene_id', sceneIds)
    .order('version', { ascending: false })
  
  if (data) {
    // Í∞Å Ïî¨Ïùò ÏµúÏã† Î≤ÑÏ†ÑÎßå Ï†ÄÏû•
    const latestByScene = {}
    data.forEach(item => {
      if (!latestByScene[item.scene_id] || item.version > latestByScene[item.scene_id].version) {
        latestByScene[item.scene_id] = item
      }
    })
    
    // TTS Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
    Object.values(latestByScene).forEach(item => {
      ttsData.value[item.scene_id] = {
        file_url: item.file_url,
        duration: item.duration,
        version: item.version
      }
    })
  }
}

// Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏ Ïãú TTS ÌôïÏù∏
onMounted(() => {
  checkExistingTTS()
})

// Ïª¥Ìè¨ÎÑåÌä∏ Ïñ∏ÎßàÏö¥Ìä∏ Ïãú Ïò§ÎîîÏò§ Ï†ïÎ¶¨
onUnmounted(() => {
  Object.values(audioElements.value).forEach(audio => {
    if (audio) {
      audio.pause()
      audio.src = ''
    }
  })
})


// export deleteSelectedScenes for parent component
defineExpose({ deleteSelectedScenes })
</script>

<style scoped>
.production-table-wrapper {
  width: 100%;
  position: relative;
  height: 100%;
  overflow-y: auto;
  padding: 20px;
  padding-top: 10px;
}

/* ÏÑπÏÖò Ìó§Îçî - Ïù¥ÎØ∏ÏßÄÎ∑∞ÏôÄ Ïä§ÌÉÄÏùº ÌÜµÏùº */
.section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
  padding: 0;
}

.section-header h4 {
  font-size: 1.1rem;
  font-weight: 600;
  color: var(--text-primary);
}

.filter-options {
  display: flex;
  gap: 12px;
}

/* ÏÑ†ÌÉù Ïï°ÏÖò Î∞î */
.selection-actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  background: linear-gradient(135deg, rgba(74, 222, 128, 0.1), rgba(34, 197, 94, 0.05));
  border: 1px solid rgba(74, 222, 128, 0.3);
  border-radius: 8px;
  margin-bottom: 12px;
  animation: slideDown 0.2s ease-out;
}

@keyframes slideDown {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.selection-info {
  display: flex;
  align-items: center;
  gap: 12px;
}

.selection-count {
  font-weight: 600;
  color: var(--primary-color);
  font-size: 0.95rem;
}

.selection-buttons {
  display: flex;
  gap: 8px;
}

.btn-tts,
.btn-download-tts {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 14px;
  background-color: var(--primary-color);
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 0.9rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-download-tts {
  background-color: #10b981;
}

.btn-tts:hover,
.btn-download-tts:hover {
  background-color: var(--primary-dark);
  transform: translateY(-1px);
  box-shadow: 0 2px 8px rgba(79, 70, 229, 0.3);
}

.btn-download-tts:hover {
  background-color: #059669;
  box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
}

.btn-tts svg,
.btn-download-tts svg {
  width: 16px;
  height: 16px;
}

.btn-delete {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 14px;
  background-color: #ef4444;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 0.9rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-delete:hover {
  background-color: #dc2626;
  transform: translateY(-1px);
  box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
}

.btn-delete svg {
  width: 16px;
  height: 16px;
}

.btn-cancel {
  padding: 6px 14px;
  background-color: var(--bg-secondary);
  color: var(--text-primary);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  font-size: 0.9rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-cancel:hover {
  background-color: var(--bg-tertiary);
  border-color: var(--text-secondary);
}

.production-table-container {
  width: 100%;
  max-height: calc(100vh - 150px);
  overflow-y: auto;
  overflow-x: auto;
  border: 1px solid var(--border-color);
  border-radius: 8px;
}

.production-table-container::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

.production-table-container::-webkit-scrollbar-track {
  background: var(--bg-secondary);
  border-radius: 4px;
}

.production-table-container::-webkit-scrollbar-thumb {
  background: var(--border-color);
  border-radius: 4px;
}

.production-table-container::-webkit-scrollbar-thumb:hover {
  background: var(--text-secondary);
}

.production-table {
  width: 100%;
  border-collapse: collapse;
  background-color: var(--bg-primary);
}

.production-table thead {
  background-color: var(--bg-secondary);
  position: sticky;
  top: 0;
  z-index: 10;
}

.production-table th {
  padding: 12px;
  text-align: center;
  font-weight: 600;
  color: var(--text-primary);
  border-bottom: 2px solid var(--border-color);
  white-space: nowrap;
}

.production-table tbody tr {
  border-bottom: 1px solid var(--border-color);
  transition: background-color 0.2s;
  min-height: 140px;
}

.production-table tbody tr:hover {
  background-color: var(--bg-secondary);
}

.production-table tbody tr.selected {
  background-color: rgba(74, 222, 128, 0.1);
}

.production-table td {
  padding: 12px;
  vertical-align: middle;
  color: var(--text-primary);
}

/* Media type switcher */
.media-header {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 4px 0;
}

/* Switch container */
.media-switch-container {
  display: flex;
  align-items: center;
  gap: 10px;
}

.media-label {
  font-size: 0.85rem;
  color: var(--text-secondary);
  transition: color 0.3s;
  font-weight: 500;
}

.media-label.active {
  font-weight: 600;
}

/* Ïù¥ÎØ∏ÏßÄ Î†àÏù¥Î∏î ÌôúÏÑ±Ìôî Ïãú ÌååÎûÄÏÉâ */
.media-label:first-child.active {
  color: #60a5fa;
}

/* ÎπÑÎîîÏò§ Î†àÏù¥Î∏î ÌôúÏÑ±Ìôî Ïãú Ï¥àÎ°ùÏÉâ */
.media-label:last-child.active {
  color: var(--primary-color);
}

/* Toggle switch styles */
.media-switch {
  position: relative;
  display: inline-block;
  width: 44px;
  height: 24px;
}

.media-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.switch-slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #60a5fa; /* Ïù¥ÎØ∏ÏßÄ Î™®Îìú: ÌååÎûÄÏÉâ */
  transition: all 0.3s;
  border-radius: 24px;
}

.switch-slider:before {
  position: absolute;
  content: "";
  height: 18px;
  width: 18px;
  left: 3px;
  bottom: 3px;
  background-color: white;
  transition: all 0.3s;
  border-radius: 50%;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.media-switch input:checked + .switch-slider {
  background-color: var(--primary-color); /* ÎπÑÎîîÏò§ Î™®Îìú: Ï¥àÎ°ùÏÉâ */
}

.media-switch input:checked + .switch-slider:before {
  transform: translateX(20px);
}

.media-switch:hover .switch-slider {
  opacity: 0.9;
}

.media-switch input:not(:checked):hover + .switch-slider {
  background-color: #3b82f6; /* Ïù¥ÎØ∏ÏßÄ Î™®Îìú Ìò∏Î≤Ñ: ÏßÑÌïú ÌååÎûÄÏÉâ */
}

.media-switch input:checked:hover + .switch-slider {
  background-color: var(--primary-dark); /* ÎπÑÎîîÏò§ Î™®Îìú Ìò∏Î≤Ñ: ÏßÑÌïú Ï¥àÎ°ùÏÉâ */
}

/* Old media type switcher styles - kept for fallback */
/* .media-type-switcher {
  display: inline-flex;
  align-items: center;
  gap: 2px;
  padding: 2px 8px;
  background: var(--bg-tertiary);
  border-radius: 6px;
}

.media-type-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  font-size: 0.9rem;
  font-weight: 500;
  cursor: pointer;
  padding: 2px 8px;
  border-radius: 4px;
  transition: all 0.2s;
}

.media-type-btn:hover {
  color: var(--text-primary);
  background: var(--bg-secondary);
}

.media-type-btn.active {
  color: white;
  background: var(--primary-color);
}

.separator {
  color: var(--text-tertiary);
  font-size: 0.9rem;
} */

/* Column widths */
.scene-number-col {
  width: 60px;
  text-align: center;
  vertical-align: middle;
}

.scene-number-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.scene-number {
  font-weight: 600;
  color: var(--text-primary);
  font-size: 14px;
}

.scene-image-col {
  width: 200px;
  text-align: center;
  padding: 8px;
  vertical-align: middle;
}

.script-col {
  min-width: 280px;
  max-width: 380px;
}

.characters-col {
  min-width: 80px;
  max-width: 150px;
}

.tts-col {
  width: 150px;
  text-align: center;
}

/* ÏïÑÏù¥ÏΩò Ïä§ÌÉÄÏùº */
.icon-wrapper {
  display: inline-flex;
  align-items: center;
  gap: 4px;
}

.icon-wrapper svg {
  width: 20px;
  height: 20px;
}

.icon-data {
  color: #3b82f6;
}

.icon-infographic {
  color: #4ade80;
}

.icon-text {
  font-size: 0.75rem;
  font-weight: 500;
  display: none;
}

@media (min-width: 1024px) {
  .icon-text {
    display: inline;
  }
}

/* Ïù∏ÎùºÏù∏ Ìé∏Ïßë Ïä§ÌÉÄÏùº */
.editable-cell {
  cursor: text;
  position: relative;
}

.editable-cell:hover {
  background-color: rgba(74, 222, 128, 0.05);
}

.edit-input,
.edit-textarea {
  width: 100%;
  padding: 8px;
  border: 2px solid var(--primary-color);
  border-radius: 4px;
  background-color: var(--bg-primary);
  color: var(--text-primary);
  font-family: inherit;
  font-size: inherit;
  outline: none;
}

.edit-textarea {
  resize: vertical;
  min-height: 60px;
  line-height: 1.5;
}

.edit-hint {
  font-size: 0.75rem;
  color: var(--text-secondary);
  margin-top: 4px;
}

.empty-hint {
  color: var(--text-secondary);
  font-style: italic;
  font-size: 0.85rem;
  cursor: pointer;
}

/* Tags */
.tag-list {
  display: flex;
  flex-wrap: wrap;
  gap: 3px;
}

.tag {
  display: inline-block;
  padding: 2px 6px;
  border-radius: 10px;
  font-size: 0.75rem;
  font-weight: 500;
  white-space: nowrap;
}

.character-tag {
  background-color: rgba(168, 85, 247, 0.15);
  color: #a855f7;
  font-size: 0.75rem;
  padding: 1px 6px;
}

/* TTS Ï¥ù ÎìÄÎ†àÏù¥ÏÖò ÌëúÏãú */
.tts-total-duration {
  font-weight: normal;
  color: var(--text-secondary);
  font-size: 0.85rem;
  margin-left: 4px;
}

/* TTS Ïª®Ìä∏Î°§ Ïä§ÌÉÄÏùº */
.tts-controls {
  display: flex;
  flex-direction: column;
  gap: 4px;
  align-items: center;
  justify-content: center;
}

.tts-generate-btn {
  width: 60px;
  padding: 5px 8px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  background-color: var(--bg-secondary);
  color: var(--text-primary);
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 12px;
  font-weight: 500;
}

.tts-generate-btn:hover:not(:disabled) {
  background-color: var(--primary-color);
  border-color: var(--primary-color);
  color: white;
}

.tts-generate-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.tts-play-btn {
  width: 60px;
  padding: 5px 8px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  background-color: var(--bg-secondary);
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 14px;
}

.tts-play-btn:hover {
  background-color: var(--primary-color);
  border-color: var(--primary-color);
  color: white;
}

.tts-play-btn.playing {
  background-color: #10b981;
  border-color: #10b981;
  color: white;
}

.tts-duration {
  font-size: 12px;
  color: var(--text-secondary);
  font-family: monospace;
  padding: 2px 0;
}

.tts-regenerate-btn {
  width: 60px;
  padding: 5px 8px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  background-color: var(--bg-secondary);
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 12px;
  font-weight: 500;
}

.tts-regenerate-btn:hover:not(:disabled) {
  background-color: #fbbf24;
  border-color: #fbbf24;
  opacity: 1;
}

.tts-regenerate-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.tts-download-btn {
  width: 60px;
  padding: 5px 8px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  background-color: var(--bg-secondary);
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 14px;
  font-weight: 500;
}

.tts-download-btn:hover {
  background-color: #3b82f6;
  border-color: #3b82f6;
  color: white;
}

.loading-spinner-small {
  width: 12px;
  height: 12px;
  border: 2px solid var(--border-color);
  border-top: 2px solid var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Ïî¨ Ïù¥ÎØ∏ÏßÄ Ïä§ÌÉÄÏùºÏùÄ SceneImageUploader Ïª¥Ìè¨ÎÑåÌä∏Î°ú Ïù¥Îèô */

/* Ïî¨ Íµ¨Î∂ÑÏÑ† Ìñâ */
.scene-divider-row {
  height: 0;
  position: relative;
}

.scene-divider-cell {
  padding: 0 !important;
  height: 0;
  position: relative;
  border: none !important;
}

/* Ïî¨ Ï∂îÍ∞Ä Î≤ÑÌäº Ïò§Î≤ÑÎ†àÏù¥ */
.add-scene-overlay {
  position: absolute;
  top: -20px;
  left: 0;
  right: 0;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: transparent;
  opacity: 0;
  transition: opacity 0.2s ease;
  pointer-events: none;
  z-index: 5;
}

.add-scene-overlay.visible {
  opacity: 1;
  pointer-events: all;
}

.add-scene-overlay-button {
  padding: 6px 20px;
  background: var(--bg-primary);
  border: 1px solid var(--primary-color);
  border-radius: 20px;
  color: var(--primary-color);
  font-size: 0.85rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.add-scene-overlay-button:hover {
  background: var(--primary-color);
  color: var(--bg-primary);
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(74, 222, 128, 0.3);
}

/* No data message */
.no-data {
  text-align: center;
  padding: 60px 20px;
  color: var(--text-secondary);
}

/* Checkbox styling */
input[type="checkbox"] {
  width: 18px;
  height: 18px;
  cursor: pointer;
  accent-color: var(--primary-color);
}

/* Mobile responsive */
@media (max-width: 768px) {
  .production-table {
    font-size: 0.9rem;
  }
  
  .production-table th,
  .production-table td {
    padding: 8px;
  }
  
  .script-col {
    min-width: 200px;
  }
  
  .tag {
    font-size: 0.8rem;
    padding: 3px 8px;
  }
}
</style>